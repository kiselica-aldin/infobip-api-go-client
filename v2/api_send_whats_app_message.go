/**
 * Infobip Client API Libraries OpenAPI Specification
 *
 * OpenAPI specification containing public endpoints supported in client API libraries.
 *
 * Contact: support@infobip.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

package infobip

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// SendWhatsAppMessageApiService SendWhatsAppMessageApi service
type SendWhatsAppMessageApiService service

type ApiSendWhatsappAudioMessageRequest struct {
	ctx                                       _context.Context
	ApiService                                *SendWhatsAppMessageApiService
	whatsAppApiMessageAudioWhatsAppApiContent *WhatsAppApiMessageAudioWhatsAppApiContent
}

func (r ApiSendWhatsappAudioMessageRequest) WhatsAppApiMessageAudioWhatsAppApiContent(whatsAppApiMessageAudioWhatsAppApiContent WhatsAppApiMessageAudioWhatsAppApiContent) ApiSendWhatsappAudioMessageRequest {
	r.whatsAppApiMessageAudioWhatsAppApiContent = &whatsAppApiMessageAudioWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappAudioMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappAudioMessageExecute(r)
}

/*
 * SendWhatsappAudioMessage Send WhatsApp audio message
 * Send an audio to a single recipient. Audio messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappAudioMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappAudioMessage(ctx _context.Context) ApiSendWhatsappAudioMessageRequest {
	return ApiSendWhatsappAudioMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappAudioMessageExecute(r ApiSendWhatsappAudioMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappAudioMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/audio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageAudioWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageAudioWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageAudioWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappContactMessageRequest struct {
	ctx                                          _context.Context
	ApiService                                   *SendWhatsAppMessageApiService
	whatsAppApiMessageContactsWhatsAppApiContent *WhatsAppApiMessageContactsWhatsAppApiContent
}

func (r ApiSendWhatsappContactMessageRequest) WhatsAppApiMessageContactsWhatsAppApiContent(whatsAppApiMessageContactsWhatsAppApiContent WhatsAppApiMessageContactsWhatsAppApiContent) ApiSendWhatsappContactMessageRequest {
	r.whatsAppApiMessageContactsWhatsAppApiContent = &whatsAppApiMessageContactsWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappContactMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappContactMessageExecute(r)
}

/*
 * SendWhatsappContactMessage Send WhatsApp contact message
 * Send a contact to a single recipient. Contact messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappContactMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappContactMessage(ctx _context.Context) ApiSendWhatsappContactMessageRequest {
	return ApiSendWhatsappContactMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappContactMessageExecute(r ApiSendWhatsappContactMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappContactMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/contact"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageContactsWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageContactsWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageContactsWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappDocumentMessageRequest struct {
	ctx                                          _context.Context
	ApiService                                   *SendWhatsAppMessageApiService
	whatsAppApiMessageDocumentWhatsAppApiContent *WhatsAppApiMessageDocumentWhatsAppApiContent
}

func (r ApiSendWhatsappDocumentMessageRequest) WhatsAppApiMessageDocumentWhatsAppApiContent(whatsAppApiMessageDocumentWhatsAppApiContent WhatsAppApiMessageDocumentWhatsAppApiContent) ApiSendWhatsappDocumentMessageRequest {
	r.whatsAppApiMessageDocumentWhatsAppApiContent = &whatsAppApiMessageDocumentWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappDocumentMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappDocumentMessageExecute(r)
}

/*
 * SendWhatsappDocumentMessage Send WhatsApp document message
 * Send a document to a single recipient. Document messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappDocumentMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappDocumentMessage(ctx _context.Context) ApiSendWhatsappDocumentMessageRequest {
	return ApiSendWhatsappDocumentMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappDocumentMessageExecute(r ApiSendWhatsappDocumentMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappDocumentMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/document"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageDocumentWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageDocumentWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageDocumentWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappImageMessageRequest struct {
	ctx                                       _context.Context
	ApiService                                *SendWhatsAppMessageApiService
	whatsAppApiMessageImageWhatsAppApiContent *WhatsAppApiMessageImageWhatsAppApiContent
}

func (r ApiSendWhatsappImageMessageRequest) WhatsAppApiMessageImageWhatsAppApiContent(whatsAppApiMessageImageWhatsAppApiContent WhatsAppApiMessageImageWhatsAppApiContent) ApiSendWhatsappImageMessageRequest {
	r.whatsAppApiMessageImageWhatsAppApiContent = &whatsAppApiMessageImageWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappImageMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappImageMessageExecute(r)
}

/*
 * SendWhatsappImageMessage Send WhatsApp image message
 * Send an image to a single recipient. Image messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappImageMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappImageMessage(ctx _context.Context) ApiSendWhatsappImageMessageRequest {
	return ApiSendWhatsappImageMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappImageMessageExecute(r ApiSendWhatsappImageMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappImageMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/image"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageImageWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageImageWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageImageWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappLocationMessageRequest struct {
	ctx                                          _context.Context
	ApiService                                   *SendWhatsAppMessageApiService
	whatsAppApiMessageLocationWhatsAppApiContent *WhatsAppApiMessageLocationWhatsAppApiContent
}

func (r ApiSendWhatsappLocationMessageRequest) WhatsAppApiMessageLocationWhatsAppApiContent(whatsAppApiMessageLocationWhatsAppApiContent WhatsAppApiMessageLocationWhatsAppApiContent) ApiSendWhatsappLocationMessageRequest {
	r.whatsAppApiMessageLocationWhatsAppApiContent = &whatsAppApiMessageLocationWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappLocationMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappLocationMessageExecute(r)
}

/*
 * SendWhatsappLocationMessage Send WhatsApp location message
 * Send a location to a single recipient. Location messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappLocationMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappLocationMessage(ctx _context.Context) ApiSendWhatsappLocationMessageRequest {
	return ApiSendWhatsappLocationMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappLocationMessageExecute(r ApiSendWhatsappLocationMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappLocationMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/location"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageLocationWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageLocationWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageLocationWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappStickerMessageRequest struct {
	ctx                                         _context.Context
	ApiService                                  *SendWhatsAppMessageApiService
	whatsAppApiMessageStickerWhatsAppApiContent *WhatsAppApiMessageStickerWhatsAppApiContent
}

func (r ApiSendWhatsappStickerMessageRequest) WhatsAppApiMessageStickerWhatsAppApiContent(whatsAppApiMessageStickerWhatsAppApiContent WhatsAppApiMessageStickerWhatsAppApiContent) ApiSendWhatsappStickerMessageRequest {
	r.whatsAppApiMessageStickerWhatsAppApiContent = &whatsAppApiMessageStickerWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappStickerMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappStickerMessageExecute(r)
}

/*
 * SendWhatsappStickerMessage Send WhatsApp sticker message
 * Send a sticker to a single recipient. Sticker messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappStickerMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappStickerMessage(ctx _context.Context) ApiSendWhatsappStickerMessageRequest {
	return ApiSendWhatsappStickerMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappStickerMessageExecute(r ApiSendWhatsappStickerMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappStickerMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/sticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageStickerWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageStickerWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageStickerWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappTemplateMessageRequest struct {
	ctx                    _context.Context
	ApiService             *SendWhatsAppMessageApiService
	whatsAppApiBulkMessage *WhatsAppApiBulkMessage
}

func (r ApiSendWhatsappTemplateMessageRequest) WhatsAppApiBulkMessage(whatsAppApiBulkMessage WhatsAppApiBulkMessage) ApiSendWhatsappTemplateMessageRequest {
	r.whatsAppApiBulkMessage = &whatsAppApiBulkMessage
	return r
}

func (r ApiSendWhatsappTemplateMessageRequest) Execute() (WhatsAppBulkMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappTemplateMessageExecute(r)
}

/*
 * SendWhatsappTemplateMessage Send WhatsApp template message
 * Send a single or multiple template messages to a one or more recipients. Template messages can be sent and delivered at anytime. Each template sent needs to be registered and pre-approved by WhatsApp.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappTemplateMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappTemplateMessage(ctx _context.Context) ApiSendWhatsappTemplateMessageRequest {
	return ApiSendWhatsappTemplateMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppBulkMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappTemplateMessageExecute(r ApiSendWhatsappTemplateMessageRequest) (WhatsAppBulkMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppBulkMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappTemplateMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiBulkMessage == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiBulkMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiBulkMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappTextMessageRequest struct {
	ctx                                      _context.Context
	ApiService                               *SendWhatsAppMessageApiService
	whatsAppApiMessageTextWhatsAppApiContent *WhatsAppApiMessageTextWhatsAppApiContent
}

func (r ApiSendWhatsappTextMessageRequest) WhatsAppApiMessageTextWhatsAppApiContent(whatsAppApiMessageTextWhatsAppApiContent WhatsAppApiMessageTextWhatsAppApiContent) ApiSendWhatsappTextMessageRequest {
	r.whatsAppApiMessageTextWhatsAppApiContent = &whatsAppApiMessageTextWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappTextMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappTextMessageExecute(r)
}

/*
 * SendWhatsappTextMessage Send WhatsApp text message
 * Send a text message to a single recipient. Text messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappTextMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappTextMessage(ctx _context.Context) ApiSendWhatsappTextMessageRequest {
	return ApiSendWhatsappTextMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappTextMessageExecute(r ApiSendWhatsappTextMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappTextMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/text"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageTextWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageTextWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageTextWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendWhatsappVideoMessageRequest struct {
	ctx                                       _context.Context
	ApiService                                *SendWhatsAppMessageApiService
	whatsAppApiMessageVideoWhatsAppApiContent *WhatsAppApiMessageVideoWhatsAppApiContent
}

func (r ApiSendWhatsappVideoMessageRequest) WhatsAppApiMessageVideoWhatsAppApiContent(whatsAppApiMessageVideoWhatsAppApiContent WhatsAppApiMessageVideoWhatsAppApiContent) ApiSendWhatsappVideoMessageRequest {
	r.whatsAppApiMessageVideoWhatsAppApiContent = &whatsAppApiMessageVideoWhatsAppApiContent
	return r
}

func (r ApiSendWhatsappVideoMessageRequest) Execute() (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	return r.ApiService.SendWhatsappVideoMessageExecute(r)
}

/*
 * SendWhatsappVideoMessage Send WhatsApp video message
 * Send a video to a single recipient. Video messages can only be successfully delivered, if the recipient has contacted the business within the last 24 hours, otherwise template message should be used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendWhatsappVideoMessageRequest
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappVideoMessage(ctx _context.Context) ApiSendWhatsappVideoMessageRequest {
	return ApiSendWhatsappVideoMessageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return WhatsAppSingleMessageInfo
 */
func (a *SendWhatsAppMessageApiService) SendWhatsappVideoMessageExecute(r ApiSendWhatsappVideoMessageRequest) (WhatsAppSingleMessageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhatsAppSingleMessageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendWhatsAppMessageApiService.SendWhatsappVideoMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/whatsapp/1/message/video"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.whatsAppApiMessageVideoWhatsAppApiContent == nil {
		return localVarReturnValue, nil, reportError("whatsAppApiMessageVideoWhatsAppApiContent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.whatsAppApiMessageVideoWhatsAppApiContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v WhatsAppApiException
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
